commit 47ed6f2f45f27de1f6327007a07d45ba48e013c0
Author: vkarri <vkarri@contoso.com>
Date:   Thu Apr 3 23:14:46 2025 +0000

    zebra: send v6 fast RA at faster interval
    
    Issue:
    Commit 6a75d33 added more
    time interval for fast RA (1000 ms), which is wrong, default
    behavior prior to this commit was 10 ms. This fix applies back
    same time interval for fast RA, ie 10 ms
    
    Fix:
    There are two wheel timers. One is for regular v6 RA advertisement,
    this is exiting one. If RA interval is configured more than 1 sec,
    we try to send out certain number of RAs (configurable), back to to
    back for an interface, with an interval of 10 ms(best effort) for
    the same interface. To handle the sending fast RA, a new faster
    wheel timer is added, which has period of 10 ms and 10 slots to
    hold the interfaces. If fast RA applicable, an interface is added
    to this new fast wheel first, once all fast RA is done for an interface,
    it is removed from this fast wheel, and added to regular wheel for RA.
    Once fast RA is detected empty, it is stopped. later if any new element
    is added to it, will be started again. Regular wheel timer has period of
    1 sec and 10 slots, so has a precision ~= 100 ms. As long as interfaces
    are up, they will be always in this wheel. So, this wheel is supposed
    to run forever.
    
    Testing:
    show bgp summary for 512 bgp peers for bgp bgp unnumbered works fine.
    
    Signed-off-by: Soumya Roy <souroy@nvidia.com>

diff --git a/zebra/rtadv.c b/zebra/rtadv.c
index 4b1c90a205..987ef91b99 100644
--- a/zebra/rtadv.c
+++ b/zebra/rtadv.c
@@ -501,7 +501,32 @@ static void start_icmpv6_join_timer(struct event *thread)
 			   ifp->vrf->name, ifp->ifindex);
 }
 
-void process_rtadv(void *arg)
+void process_rtadv_regular(void *arg)
+{
+	struct interface *ifp = arg;
+	struct zebra_if *zif = ifp->info;
+	struct zebra_vrf *zvrf = rtadv_interface_get_zvrf(ifp);
+
+	zif->rtadv.AdvIntervalTimer -= RTADV_TIMER_REGULAR_WHEEL_PERIOD_MS;
+	/* Wait atleast AdvIntervalTimer time before sending next RA
+	 * AdvIntervalTimer can go negative, when ra_wheel timer expiry
+	 * interval is not a multiple of AdvIntervalTimer. Say ra_wheel
+	 * expiry time is 10 ms and, AdvIntervalTimer == 1005 ms. Allowing
+	 * AdvIntervalTimer to go negative and checking, gurantees that
+	 * we have waited Wait atleast AdvIntervalTimer, so RA can be
+	 * sent now.
+	 */
+	if (zif->rtadv.AdvIntervalTimer <= 0) {
+		zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;
+		if (IS_ZEBRA_DEBUG_SEND)
+			zlog_debug("Doing regular RA Rexmit on interface %s(%s:%u)", ifp->name,
+				   ifp->vrf->name, ifp->ifindex);
+
+		rtadv_send_packet(zvrf->rtadv.sock, ifp, RA_ENABLE);
+	}
+}
+
+void process_rtadv_faster(void *arg)
 {
 	struct interface *ifp = arg;
 	struct zebra_if *zif = ifp->info;
@@ -511,29 +536,13 @@ void process_rtadv(void *arg)
 		if (--zif->rtadv.NumFastReXmitsRemain <= 0)
 			zif->rtadv.inFastRexmit = 0;
 
+		wheel_remove_item(zrouter.ra_fast_wheel, ifp);
+		wheel_add_item(zrouter.ra_regular_wheel, ifp);
 		if (IS_ZEBRA_DEBUG_SEND)
 			zlog_debug("Doing fast RA Rexmit on interface %s(%s:%u)", ifp->name,
 				   ifp->vrf->name, ifp->ifindex);
 
 		rtadv_send_packet(zvrf->rtadv.sock, ifp, RA_ENABLE);
-	} else {
-		zif->rtadv.AdvIntervalTimer -= RTADV_TIMER_WHEEL_PERIOD_MS;
-		/* Wait atleast AdvIntervalTimer time before sending next RA
-		 * AdvIntervalTimer can go negative, when ra_wheel timer expiry
-		 * interval is not a multiple of AdvIntervalTimer. Say ra_wheel
-		 * expiry time is 10 ms and, AdvIntervalTimer == 1005 ms. Allowing 
-		 * AdvIntervalTimer to go negative and checking, gurantees that
-		 * we have waited Wait atleast AdvIntervalTimer, so RA can be 
-		 * sent now.
-		*/
-		if (zif->rtadv.AdvIntervalTimer <= 0) {
-			zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;
-			if (IS_ZEBRA_DEBUG_SEND)
-				zlog_debug("Doing regular RA Rexmit on interface %s(%s:%u)",
-					   ifp->name, ifp->vrf->name, ifp->ifindex);
-
-			rtadv_send_packet(zvrf->rtadv.sock, ifp, RA_ENABLE);
-		}
 	}
 }
 
@@ -1100,21 +1109,22 @@ static struct adv_if *adv_if_del(struct zebra_vrf *zvrf, const char *name)
  * Add to list. On Success, return NULL, otherwise return already existing
  * adv_if.
  */
-static struct adv_if *adv_msec_if_add(struct zebra_vrf *zvrf, const char *name)
+static struct adv_if *adv_msec_if_add(struct zebra_vrf *zvrf, struct interface *ifp)
 {
 	struct adv_if *adv_if = NULL;
 
-	adv_if = adv_if_add_internal(&zvrf->rtadv.adv_msec_if, name);
-
+	adv_if = adv_if_add_internal(&zvrf->rtadv.adv_msec_if, ifp->name);
+	/* Try to remove from regular wheel to fast wheel */
+	wheel_remove_item(zrouter.ra_regular_wheel, ifp);
+	wheel_add_item(zrouter.ra_fast_wheel, ifp);
 	if (adv_if != NULL)
 		return adv_if;
 
 	if (IS_ZEBRA_DEBUG_EVENT) {
 		struct vrf *vrf = zvrf->vrf;
 
-		zlog_debug("%s: %s:%u IF %s count: %zu", __func__,
-			   VRF_LOGNAME(vrf), zvrf_id(zvrf), name,
-			   adv_if_list_count(&zvrf->rtadv.adv_msec_if));
+		zlog_debug("%s: %s:%u IF %s count: %zu", __func__, VRF_LOGNAME(vrf), zvrf_id(zvrf),
+			   ifp->name, adv_if_list_count(&zvrf->rtadv.adv_msec_if));
 	}
 
 	return NULL;
@@ -1332,6 +1342,11 @@ static void rtadv_start_interface_events(struct zebra_vrf *zvrf,
 		return;
 	}
 
+	if (zif->rtadv.inFastRexmit)
+		wheel_add_item(zrouter.ra_fast_wheel, zif->ifp);
+	else
+		wheel_add_item(zrouter.ra_regular_wheel, zif->ifp);
+
 	adv_if = adv_if_add(zvrf, zif->ifp->name);
 	if (adv_if != NULL)
 		return; /* Already added */
@@ -1362,8 +1377,12 @@ void ipv6_nd_suppress_ra_set(struct interface *ifp,
 	if (status == RA_SUPPRESS) {
 		/* RA is currently enabled */
 		if (zif->rtadv.AdvSendAdvertisements) {
-			/* Try to delete from the ra wheel */
-			wheel_remove_item(zrouter.ra_wheel, ifp);
+			/* Try to delete from the ra wheels */
+			if (zif->rtadv.inFastRexmit)
+				wheel_remove_item(zrouter.ra_fast_wheel, ifp);
+			else
+				wheel_remove_item(zrouter.ra_regular_wheel, ifp);
+
 			rtadv_send_packet(zvrf->rtadv.sock, ifp, RA_SUPPRESS);
 			zif->rtadv.AdvSendAdvertisements = 0;
 			zif->rtadv.AdvIntervalTimer = 0;
@@ -1390,11 +1409,9 @@ void ipv6_nd_suppress_ra_set(struct interface *ifp,
 				 * secs and Fast RA retransmit is enabled
 				 */
 				zif->rtadv.inFastRexmit = 1;
-				zif->rtadv.NumFastReXmitsRemain =
-					RTADV_NUM_FAST_REXMITS;
+				zif->rtadv.NumFastReXmitsRemain = RTADV_NUM_FAST_REXMITS;
 			}
 
-			wheel_add_item(zrouter.ra_wheel, ifp);
 			rtadv_start_interface_events(zvrf, zif);
 		}
 	}
@@ -1413,7 +1430,7 @@ void ipv6_nd_interval_set(struct interface *ifp, uint32_t interval)
 	}
 
 	if (interval % 1000)
-		(void)adv_msec_if_add(zvrf, ifp->name);
+		(void)adv_msec_if_add(zvrf, ifp);
 
 	zif->rtadv.MaxRtrAdvInterval = interval;
 	zif->rtadv.MinRtrAdvInterval = 0.33 * interval;
@@ -1523,7 +1540,10 @@ void rtadv_stop_ra(struct interface *ifp)
 	zvrf = rtadv_interface_get_zvrf(ifp);
 
 	/*Try to delete from ra wheels */
-	wheel_remove_item(zrouter.ra_wheel, ifp);
+	if (zif->rtadv.inFastRexmit)
+		wheel_remove_item(zrouter.ra_fast_wheel, ifp);
+	else
+		wheel_remove_item(zrouter.ra_regular_wheel, ifp);
 
 	/*Turn off event for ICMPv6 join*/
 	EVENT_OFF(zif->icmpv6_join_timer);
diff --git a/zebra/rtadv.h b/zebra/rtadv.h
index 73d737ce41..fe13608318 100644
--- a/zebra/rtadv.h
+++ b/zebra/rtadv.h
@@ -460,7 +460,8 @@ extern void zebra_interface_radv_enable(ZAPI_HANDLER_ARGS);
 extern uint32_t rtadv_get_interfaces_configured_from_bgp(void);
 extern bool rtadv_compiled_in(void);
 extern void rtadv_init(void);
-extern void process_rtadv(void *arg);
+extern void process_rtadv_regular(void *arg);
+extern void process_rtadv_faster(void *arg);
 
 #ifdef __cplusplus
 }
diff --git a/zebra/zebra_router.c b/zebra/zebra_router.c
index ff75227e55..452c8690c1 100644
--- a/zebra/zebra_router.c
+++ b/zebra/zebra_router.c
@@ -246,11 +246,16 @@ void zebra_router_terminate(void)
 {
 	struct zebra_router_table *zrt, *tmp;
 
-	if (zrouter.ra_wheel) {
-		wheel_delete(zrouter.ra_wheel);
-		zrouter.ra_wheel = NULL;
+	if (zrouter.ra_regular_wheel) {
+		wheel_delete(zrouter.ra_regular_wheel);
+		zrouter.ra_regular_wheel = NULL;
 	}
 
+	if (zrouter.ra_fast_wheel) {
+		wheel_delete(zrouter.ra_fast_wheel);
+		zrouter.ra_fast_wheel = NULL;
+ 	}
+
 	EVENT_OFF(zrouter.sweeper);
 
 	RB_FOREACH_SAFE (zrt, zebra_router_table_head, &zrouter.tables, tmp)
@@ -306,9 +311,13 @@ void zebra_router_init(bool asic_offload, bool notify_on_ack,
 	zrouter.nhg_keep = ZEBRA_DEFAULT_NHG_KEEP_TIMER;
 
 	/*Init V6 RA batching stuffs*/
-	zrouter.ra_wheel = wheel_init(zrouter.master, RTADV_TIMER_WHEEL_PERIOD_MS,
-				      RTADV_TIMER_WHEEL_SLOTS_NO, interface_hash_key, process_rtadv,
-				      NULL);
+	zrouter.ra_regular_wheel = wheel_init(zrouter.master, RTADV_TIMER_REGULAR_WHEEL_PERIOD_MS,
+					      RTADV_TIMER_WHEEL_SLOTS_NO, 0, interface_hash_key,
+					      process_rtadv_regular, NULL, true);
+
+	zrouter.ra_fast_wheel = wheel_init(zrouter.master, RTADV_TIMER_FAST_WHEEL_PERIOD_MS,
+					   RTADV_TIMER_WHEEL_SLOTS_NO, 10, interface_hash_key,
+					   process_rtadv_faster, NULL, false);
 
 	zebra_vxlan_init();
 	zebra_mlag_init();
diff --git a/zebra/zebra_router.h b/zebra/zebra_router.h
index 67652b93d0..fd2d891fbe 100644
--- a/zebra/zebra_router.h
+++ b/zebra/zebra_router.h
@@ -123,8 +123,9 @@ struct zebra_mlag_info {
 	struct event *t_write;
 };
 
-#define RTADV_TIMER_WHEEL_PERIOD_MS 1000
-#define RTADV_TIMER_WHEEL_SLOTS_NO  100
+#define RTADV_TIMER_REGULAR_WHEEL_PERIOD_MS 1000
+#define RTADV_TIMER_WHEEL_SLOTS_NO	    10
+#define RTADV_TIMER_FAST_WHEEL_PERIOD_MS    10
 #define ICMPV6_JOIN_TIMER_EXP_MS    100
 
 struct zebra_router {
@@ -133,8 +134,13 @@ struct zebra_router {
 	/* Thread master */
 	struct event_loop *master;
 
-	/* Wheel to process V6 RA update */
-	struct timer_wheel *ra_wheel;
+
+	/* Wheel to process fast V6 RA update */
+	struct timer_wheel *ra_regular_wheel;
+
+	/* Wheel to process fast V6 RA update */
+	struct timer_wheel *ra_fast_wheel;
+
 
 	/* Lists of clients who have connected to us */
 	struct list *client_list;
